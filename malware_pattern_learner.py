import logging
import json
import os
from datetime import datetime, timezone # For timezone-aware timestamps
import uuid
from typing import Dict, List, Optional, Any

class MalwarePatternLearner:
    def __init__(self, database_path: str = "malware_patterns.json", logger: Optional[logging.Logger] = None):
        self.database_path: str = database_path
        self.logger = logger if logger else logging.getLogger(self.__class__.__name__)
        if not logger and not logging.getLogger().hasHandlers():
            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        
        self.patterns_db: Dict[str, Any] = {}
        self.initialize_pattern_database()

    def _get_timestamp(self) -> str:
        """Returns a timezone-aware ISO formatted timestamp."""
        return datetime.now(timezone.utc).isoformat()

    def initialize_pattern_database(self, force_recreate: bool = False) -> None:
        """
        Initializes the pattern database. Loads from existing file or creates a new one.
        """
        if not force_recreate and os.path.exists(self.database_path):
            if self._load_database():
                self.logger.info(f"Successfully loaded existing pattern database from {self.database_path}")
                # Ensure essential keys exist even if loading an old/minimal DB
                if "metadata" not in self.patterns_db:
                    self.patterns_db["metadata"] = {}
                if "patterns" not in self.patterns_db:
                    self.patterns_db["patterns"] = []
                # Update loaded timestamp if desired, or rely on 'updated_at'
                self.patterns_db["metadata"]["last_loaded_at"] = self._get_timestamp()
                return # Successfully loaded

            self.logger.warning(f"Failed to load database from {self.database_path}. Will create a new one.")
        
        # Create a new database structure
        self.logger.info(f"Initializing new pattern database at {self.database_path} (force_recreate={force_recreate})")
        self.patterns_db = {
            "metadata": {
                "created_at": self._get_timestamp(),
                "updated_at": self._get_timestamp(),
                "version": "0.1.0",
                "description": "Database of learned malware patterns."
            },
            "patterns": [] 
        }
        if not self._save_database(): # Attempt to save the newly created DB
             self.logger.error(f"Failed to save newly created database to {self.database_path}. Operations may not persist.")


    def _load_database(self) -> bool:
        """
        Private helper to load the database from self.database_path.
        Returns True on success, False on failure.
        """
        try:
            if not os.path.exists(self.database_path):
                self.logger.info(f"Database file {self.database_path} does not exist. Cannot load.")
                return False
            with open(self.database_path, 'r', encoding='utf-8') as f:
                self.patterns_db = json.load(f)
            self.logger.debug(f"Database loaded successfully from {self.database_path}.")
            return True
        except json.JSONDecodeError as e:
            self.logger.error(f"Error decoding JSON from database file {self.database_path}: {e}")
            self.patterns_db = {} # Reset to empty on error
            return False
        except IOError as e:
            self.logger.error(f"IOError reading database file {self.database_path}: {e}")
            self.patterns_db = {}
            return False
        except Exception as e: # Catch any other unexpected errors
            self.logger.error(f"Unexpected error loading database {self.database_path}: {e}")
            self.patterns_db = {}
            return False

    def _save_database(self) -> bool:
        """
        Private helper to save self.patterns_db to self.database_path.
        Updates 'updated_at' timestamp in metadata before saving.
        Returns True on success, False on failure.
        """
        if not self.patterns_db: # Do not save if db is empty or uninitialized properly
            self.logger.warning("Attempted to save an empty or uninitialized patterns_db. Save aborted.")
            return False
            
        try:
            # Ensure metadata exists and update 'updated_at'
            if "metadata" not in self.patterns_db:
                self.patterns_db["metadata"] = {} # Should be initialized, but as a safeguard
            self.patterns_db["metadata"]["updated_at"] = self._get_timestamp()
            
            # Create directory if it doesn't exist
            db_dir = os.path.dirname(self.database_path)
            if db_dir and not os.path.exists(db_dir): # Check if db_dir is not empty (i.e. not in current dir)
                os.makedirs(db_dir, exist_ok=True)
                self.logger.info(f"Created directory for database: {db_dir}")

            with open(self.database_path, 'w', encoding='utf-8') as f:
                json.dump(self.patterns_db, f, indent=2, ensure_ascii=False)
            self.logger.debug(f"Database saved successfully to {self.database_path}.")
            return True
        except IOError as e:
            self.logger.error(f"IOError writing database file {self.database_path}: {e}")
            return False
        except TypeError as e: # json.dump can raise TypeError for non-serializable objects
            self.logger.error(f"TypeError during JSON serialization for database {self.database_path}: {e}")
            return False
        except Exception as e: # Catch any other unexpected errors
            self.logger.error(f"Unexpected error saving database {self.database_path}: {e}")
            return False

    def add_pattern(self, pattern_details: Dict[str, Any]) -> Optional[str]:
        """
        Placeholder: Adds a new pattern to the database.
        Generates a unique pattern_id.
        """
        if "patterns" not in self.patterns_db: # Ensure 'patterns' list exists
            self.logger.error("Pattern database not correctly initialized (missing 'patterns' list). Cannot add pattern.")
            self.patterns_db["patterns"] = [] # Attempt to fix if missing

        pattern_id = str(uuid.uuid4())
        new_pattern = {
            "pattern_id": pattern_id,
            "type": pattern_details.get("type", "unknown"),
            "description": pattern_details.get("description", "No description provided."),
            "signatures": pattern_details.get("signatures", []), # Expects a list of signature elements
            "confidence": pattern_details.get("confidence", 0.0),
            "source": pattern_details.get("source", "unknown_source"),
            "created_at": self._get_timestamp(),
            "last_updated_at": self._get_timestamp(),
            # Other fields like 'tags', 'related_threats', 'mitigations' could be added
        }
        self.patterns_db["patterns"].append(new_pattern)
        self.logger.info(f"Placeholder: Added new pattern '{pattern_id}' of type '{new_pattern['type']}'.")
        
        if self._save_database():
            return pattern_id
        else:
            # Attempt to roll back the addition if save fails, to keep in-memory consistent with potential disk state
            self.patterns_db["patterns"] = [p for p in self.patterns_db["patterns"] if p.get("pattern_id") != pattern_id]
            self.logger.error(f"Failed to save database after attempting to add pattern {pattern_id}. Pattern not added.")
            return None

    def learn_from_analysis(self, analysis_results: Dict[str, Any]) -> None:
        """
        Placeholder: Main method for future learning from analysis results.
        For now, it just logs and adds a dummy pattern.
        """
        file_name = analysis_results.get("file_name", "unknown_file")
        self.logger.info(f"Placeholder: learn_from_analysis called for results from '{file_name}'.")
        self.logger.info("  (Future: This would involve complex logic to extract meaningful patterns from various analysis outputs like decompiled code, CFGs, API calls, etc.)")
        
        # Example: Create a dummy pattern based on some hypothetical finding
        dummy_pattern_description = f"Dummy pattern learned from {file_name}"
        if "findings" in analysis_results and analysis_results["findings"]: # Example of a generic top-level key
            first_finding_type = analysis_results["findings"][0].get("type", "generic_finding")
            dummy_pattern_description += f" related to {first_finding_type}"
        
        # --- Enhanced Heuristic Placeholder ---
        self.logger.info(f"Analyzing results from '{file_name}' for potential patterns...")
        
        pattern_type = "generic_learned_pattern"
        description = f"Generic pattern learned from {file_name}."
        indicators = [f"initial_indicator_from_{file_name}"]
        confidence = 0.4 # Default confidence
        source_module_for_pattern = "learn_from_analysis_heuristic"

        # Heuristic 1: Check for CodeIntentClassifier output
        intent_results = analysis_results.get("components", {}).get("CodeIntentClassifier", {})
        if intent_results and isinstance(intent_results, dict) and \
           intent_results.get("intent") not in [None, "unknown", "unknown_no_model_or_vectorizer", "unknown_dummy_model", "unknown_preprocess_failed", "unknown_classification_error", "unknown_model_missing_classes_attr"]:
            
            pattern_type = "dominant_code_intent"
            description = f"Dominant code intent observed: {intent_results['intent']}"
            indicators = [f"intent:{intent_results['intent']}"]
            if isinstance(intent_results.get("confidence"), (float, int)):
                confidence = intent_results["confidence"] * 0.7 # Adjust confidence based on intent model's confidence
            source_module_for_pattern = "CodeIntentClassifier"
            self.logger.info(f"  Derived pattern based on dominant code intent: {intent_results['intent']}")
        
        # Heuristic 2 (Fallback): Check for VulnerabilityDetector output if no strong intent found
        elif pattern_type == "generic_learned_pattern": # Only if intent didn't yield a pattern
            vuln_results = analysis_results.get("components", {}).get("VulnerabilityDetector", {})
            if vuln_results and isinstance(vuln_results, dict) and vuln_results.get("vulnerabilities_found"):
                # Let's say we consider multiple strcpy as a more specific pattern
                strcpy_findings = [f for f in vuln_results["vulnerabilities_found"] if f.get("pattern_name") == "strcpy"]
                if len(strcpy_findings) >= 2:
                    pattern_type = "multiple_strcpy_calls"
                    description = f"Multiple ({len(strcpy_findings)}) strcpy calls detected, potential widespread buffer overflow risk."
                    indicators = [f"vuln_pattern:strcpy_repeated"]
                    for i, finding in enumerate(strcpy_findings[:2]): # Add info from first two
                        indicators.append(f"strcpy_loc_{i+1}:L{finding['line_number']}_Col{finding['match_start_column']}")
                    confidence = 0.65
                    source_module_for_pattern = "VulnerabilityDetector_strcpy_heuristic"
                    self.logger.info(f"  Derived pattern based on multiple strcpy vulnerabilities.")
                else: # Generic vulnerability pattern if not multiple strcpy
                    first_vuln = vuln_results["vulnerabilities_found"][0]
                    pattern_type = "vulnerability_signature_observed"
                    description = f"Pattern based on detected vulnerability: {first_vuln['pattern_name']}"
                    indicators = [f"vuln_pattern:{first_vuln['pattern_name']}"]
                    indicators.append(f"line_content_sample:{first_vuln['line_content'][:30]}")
                    confidence = 0.55
                    source_module_for_pattern = "VulnerabilityDetector_general"
                    self.logger.info(f"  Derived pattern based on general vulnerability: {first_vuln['pattern_name']}")
            else:
                 self.logger.info(f"  No specific intent or vulnerability pattern derived from '{file_name}'. Adding generic placeholder.")
        else:
            self.logger.info(f"  No specific vulnerability pattern derived from '{file_name}' after intent check. Adding generic placeholder for intent.")


        pattern_details = {
            "type": pattern_type,
            "description": description,
            "signatures_or_indicators": indicators, 
            "confidence": confidence, 
            "source_artifact": file_name,
            "derived_from_module": source_module_for_pattern
        }
        
        self.logger.info(f"  Constructed pattern details: {pattern_details}")
        added_pattern_id = self.add_pattern(pattern_details)

        if added_pattern_id:
            self.logger.info(f"  Successfully added learned pattern '{added_pattern_id}' of type '{pattern_type}' to database.")
        else:
            self.logger.warning(f"  Failed to add learned pattern from '{file_name}' to database.")


if __name__ == '__main__':
    # Configure basic logging for the __main__ example run
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s') # DEBUG for more verbose logs
    main_logger = logging.getLogger("MalwarePatternLearnerExample")

    # Test with default path
    main_logger.info("--- Test Case 1: Default database path ---")
    learner = MalwarePatternLearner(logger=main_logger) # Pass logger
    main_logger.info(f"Initial DB state (default path): {json.dumps(learner.patterns_db, indent=2)}")
    
    pattern_id1 = learner.add_pattern({
        "type": "encryption_key_load", 
        "description": "Loads a hardcoded key into memory.",
        "signatures": ["mov eax, 0xDEADBEEF", "push eax"], 
        "confidence": 0.7,
        "source": "manual_analysis_case_123"
    })
    main_logger.info(f"Pattern ID 1 added: {pattern_id1}")
    main_logger.info(f"DB state after adding one pattern: {json.dumps(learner.patterns_db, indent=2)}")

    # Test with a specific path and force recreate
    main_logger.info("\n--- Test Case 2: Specific path and learn_from_analysis with CodeIntent ---")
    test_db_path = "test_patterns_db_intent.json"
    if os.path.exists(test_db_path):
        os.remove(test_db_path)
        
    learner_intent_test = MalwarePatternLearner(database_path=test_db_path, logger=main_logger)
    learner_intent_test.initialize_pattern_database(force_recreate=True) 
    
    analysis_res_intent = {
        "file_name": "intent_sample.exe",
        "components": {
            "CodeIntentClassifier": {
                "intent": "networking_communication",
                "confidence": 0.85,
                "all_probabilities": {"networking_communication": 0.85, "encryption": 0.1, "other": 0.05}
            }
        }
    }
    learner_intent_test.learn_from_analysis(analysis_res_intent)
    main_logger.info(f"DB state after learning from intent: {json.dumps(learner_intent_test.patterns_db, indent=2)}")
    assert len(learner_intent_test.patterns_db["patterns"]) == 1
    learned_pattern_intent = learner_intent_test.patterns_db["patterns"][0]
    assert learned_pattern_intent["type"] == "dominant_code_intent"
    assert learned_pattern_intent["description"] == "Dominant code intent observed: networking_communication"
    assert "intent:networking_communication" in learned_pattern_intent["signatures_or_indicators"]
    assert learned_pattern_intent["derived_from_module"] == "CodeIntentClassifier"

    main_logger.info("\n--- Test Case 3: learn_from_analysis with Vulnerability (multiple strcpy) ---")
    test_db_path_vuln = "test_patterns_db_vuln.json"
    if os.path.exists(test_db_path_vuln):
        os.remove(test_db_path_vuln)
    learner_vuln_test = MalwarePatternLearner(database_path=test_db_path_vuln, logger=main_logger)
    learner_vuln_test.initialize_pattern_database(force_recreate=True)

    analysis_res_vuln_strcpy = {
        "file_name": "vuln_sample_strcpy.exe",
        "components": {
            "VulnerabilityDetector": {
                "vulnerabilities_found": [
                    {"pattern_name": "strcpy", "line_number": 10, "line_content": "strcpy(buf, input);", "match_start_column": 0},
                    {"pattern_name": "strcpy", "line_number": 25, "line_content": "strcpy(dst, src);", "match_start_column": 0}
                ]
            }
        }
    }
    learner_vuln_test.learn_from_analysis(analysis_res_vuln_strcpy)
    main_logger.info(f"DB state after learning from multiple strcpy: {json.dumps(learner_vuln_test.patterns_db, indent=2)}")
    assert len(learner_vuln_test.patterns_db["patterns"]) == 1
    learned_pattern_vuln = learner_vuln_test.patterns_db["patterns"][0]
    assert learned_pattern_vuln["type"] == "multiple_strcpy_calls"
    assert "strcpy_loc_1:L10_Col0" in learned_pattern_vuln["signatures_or_indicators"]
    assert learned_pattern_vuln["derived_from_module"] == "VulnerabilityDetector_strcpy_heuristic"

    main_logger.info("\n--- Test Case 4: learn_from_analysis with Vulnerability (generic) ---")
    test_db_path_vuln_generic = "test_patterns_db_vuln_generic.json"
    if os.path.exists(test_db_path_vuln_generic):
        os.remove(test_db_path_vuln_generic)
    learner_vuln_generic_test = MalwarePatternLearner(database_path=test_db_path_vuln_generic, logger=main_logger)
    learner_vuln_generic_test.initialize_pattern_database(force_recreate=True)
    analysis_res_vuln_gets = {
        "file_name": "vuln_sample_gets.exe",
        "components": {
            "VulnerabilityDetector": {
                "vulnerabilities_found": [
                    {"pattern_name": "gets", "line_number": 15, "line_content": "gets(user_buffer);", "match_start_column": 0}
                ]
            }
        }
    }
    learner_vuln_generic_test.learn_from_analysis(analysis_res_vuln_gets)
    main_logger.info(f"DB state after learning from gets: {json.dumps(learner_vuln_generic_test.patterns_db, indent=2)}")
    assert len(learner_vuln_generic_test.patterns_db["patterns"]) == 1
    learned_pattern_vuln_g = learner_vuln_generic_test.patterns_db["patterns"][0]
    assert learned_pattern_vuln_g["type"] == "vulnerability_signature_observed"
    assert "vuln_pattern:gets" in learned_pattern_vuln_g["signatures_or_indicators"]
    assert learned_pattern_vuln_g["derived_from_module"] == "VulnerabilityDetector_general"

    main_logger.info("\n--- Test Case 5: learn_from_analysis with no specific indicators (generic fallback) ---")
    test_db_path_generic = "test_patterns_db_generic.json"
    if os.path.exists(test_db_path_generic):
        os.remove(test_db_path_generic)
    learner_generic_test = MalwarePatternLearner(database_path=test_db_path_generic, logger=main_logger)
    learner_generic_test.initialize_pattern_database(force_recreate=True)
    analysis_res_generic = {"file_name": "generic_sample.exe", "components": {}} # No relevant components
    learner_generic_test.learn_from_analysis(analysis_res_generic)
    main_logger.info(f"DB state after learning from generic results: {json.dumps(learner_generic_test.patterns_db, indent=2)}")
    assert len(learner_generic_test.patterns_db["patterns"]) == 1
    learned_pattern_gen = learner_generic_test.patterns_db["patterns"][0]
    assert learned_pattern_gen["type"] == "generic_learned_pattern"
    assert learned_pattern_gen["derived_from_module"] == "learn_from_analysis_heuristic"


    # Clean up
    main_logger.info("\n--- Cleaning up test files ---")
    paths_to_remove = [test_db_path, test_db_path_vuln, test_db_path_vuln_generic, test_db_path_generic]
    paths_to_remove.append("malware_patterns.json") # Default path from first test case
    
    for p in paths_to_remove:
        if os.path.exists(p):
            os.remove(p)
            main_logger.info(f"Removed {p}")
    
    main_logger.info("--- All tests completed ---")

```
