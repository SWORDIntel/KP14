# KP14 Known Limitations and Design Trade-offs

**Document Version:** 1.0
**Last Updated:** 2025-10-02
**Audience:** Security researchers, developers, system architects

---

## Executive Summary

This document outlines intentional limitations, design trade-offs, and unsupported features in the KP14 Advanced Steganographic Analysis & Malware Intelligence Platform. Understanding these limitations helps set appropriate expectations and guides proper usage of the platform.

### Key Points

- KP14 is a **static analysis** tool - no dynamic execution or sandboxing
- Focused on **APT41/KeyPlug malware family** - may have reduced efficacy on other threats
- **Hardware acceleration** requires specific Intel processors (NPU/GPU)
- Some advanced features require **external tools** (Radare2, IDA Pro)
- **Memory-intensive** operations may require 16GB+ RAM for large samples

---

## 1. Analysis Scope Limitations

### 1.1 Static Analysis Only

**Limitation:**
KP14 performs static analysis exclusively. It does not execute malware samples or observe runtime behavior.

**Why This Design:**
- **Security:** Eliminates risk of malware escaping to production systems
- **Performance:** Static analysis is faster and more scalable
- **Reproducibility:** Results are deterministic and consistent
- **Infrastructure:** No need for complex sandboxing infrastructure

**Impact:**
- Cannot detect runtime-only behaviors (process injection, API hooking)
- May miss dynamically constructed strings or payloads
- Cannot observe network communications or C2 callbacks
- Limited detection of anti-analysis tricks that trigger at runtime

**Workarounds:**
1. Use KP14 for initial triage, then dynamic sandbox for deep analysis
2. Combine with tools like Cuckoo Sandbox, ANY.RUN, or Joe Sandbox
3. Use extracted indicators (C2 addresses, encryption keys) in dynamic tools
4. Leverage YARA rules generated by KP14 in sandbox environments

**Recommendation:**
For comprehensive malware analysis, use KP14 as the first stage in a multi-stage pipeline:
```
Sample → KP14 (static) → Sandbox (dynamic) → SIEM (correlation)
```

---

### 1.2 Primary Focus: KeyPlug/APT41 Malware

**Limitation:**
KP14 is optimized for APT41's KeyPlug malware family. Detection patterns, behavioral models, and decryption routines are tuned for this specific threat.

**Why This Design:**
- **Specialization:** Deep expertise in one malware family beats shallow coverage of many
- **Pattern Quality:** High-fidelity detection rules reduce false positives
- **Decryption Logic:** Custom algorithms specific to KeyPlug variants
- **Intelligence Value:** Targeted threat intelligence for APT41 campaigns

**Impact:**
- Reduced detection rates for other malware families (PlugX, Winnti, Cobalt Strike)
- Behavioral patterns may not match other APT groups' tactics
- Custom decryption routines won't work on non-KeyPlug samples
- MITRE ATT&CK mappings may be incomplete for other threats

**Workarounds:**
1. Use generic PE analysis features for other malware types
2. Supplement with multi-family tools (YARA, Capa, PEStudio)
3. Extend pattern database with additional malware family signatures
4. Fork and customize for other APT groups (Lazarus, FIN7, etc.)

**Extensibility:**
KP14's modular architecture allows adding new malware family analyzers. See `DEVELOPMENT.md` for guidance on implementing custom analyzers.

---

### 1.3 File Size Constraints

**Limitation:**
Default maximum file size: **100MB**
Practical maximum (with config changes): **500MB**
Steganography scan limit: **10MB**

**Why This Design:**
- **Memory Management:** Prevents out-of-memory crashes on resource-constrained systems
- **Performance:** Analysis time grows non-linearly with file size
- **Attack Surface:** Protects against denial-of-service via oversized files
- **Typical Use Case:** 99% of malware samples are <50MB

**Impact:**
- Cannot analyze large disk images, memory dumps, or full installer ISOs
- May truncate steganography scans on high-resolution images
- Batch processing of many large files requires careful memory management

**Workarounds:**
1. Increase limits in `settings.ini`:
   ```ini
   [pe_analyzer]
   max_file_size_mb = 500

   [steganography_analyzer]
   max_appended_scan_size_mb = 50
   ```
2. Extract specific sections/resources from large files before analysis
3. Use chunked processing for very large files (manual scripting required)
4. Split batch jobs to analyze large files individually

**Performance Note:**
File analysis time scales roughly as O(n log n) where n is file size. A 500MB file may take 10-15 minutes on CPU-only systems.

---

## 2. Hardware and Platform Limitations

### 2.1 Intel NPU Acceleration Requirements

**Limitation:**
Hardware acceleration requires:
- Intel Core Ultra (Series 1 or later) processors with integrated NPU
- Intel Arc GPUs or Iris Xe Graphics (for GPU fallback)
- OpenVINO Runtime 2025.3.0 or later
- Appropriate drivers for NPU/GPU devices

**Why This Design:**
- **OpenVINO Ecosystem:** Leverages Intel's optimized ML framework
- **NPU Advantage:** 3-10× speedup with low power consumption
- **Vendor Support:** Intel provides excellent documentation and tools

**Impact:**
- No acceleration on AMD or ARM systems (CPU-only mode)
- Older Intel processors (pre-Core Ultra) limited to GPU/CPU modes
- macOS Apple Silicon (M1/M2/M3) runs CPU-only
- Raspberry Pi and embedded systems run at reduced performance

**Workarounds:**
1. Use CPU-only mode (still functional, just slower)
2. Optimize batch processing to maximize CPU efficiency
3. Use cloud instances with supported hardware (AWS c7i, Azure D_v5)
4. Consider hybrid approach: triage on local CPU, deep analysis on cloud NPU

**AMD Users:**
AMD ROCm support is not currently implemented but could be added. See GitHub issue #TBD for status.

**Apple Silicon Users:**
Metal Performance Shaders (MPS) integration is planned for Q1 2026.

---

### 2.2 Operating System Support

**Fully Supported:**
- Ubuntu 22.04+ (recommended)
- Debian 12+ (Bookworm)
- Windows 10/11 (with limitations)

**Limited Support:**
- macOS 12+ (CPU-only, no NPU/GPU)
- Other Linux distributions (may require manual dependency installation)

**Not Supported:**
- Windows 7/8 (Python 3.11 compatibility issues)
- 32-bit operating systems (x86 only, not x86_64)

**Why This Design:**
- **Development Focus:** Primary development on Ubuntu 22.04
- **OpenVINO Support:** Best on Linux, good on Windows, limited on macOS
- **Testing Resources:** Limited QA resources require prioritization

**Impact:**
- macOS users cannot leverage hardware acceleration
- Windows users may experience driver issues with NPU
- Exotic Linux distros may need manual dependency compilation

**Workarounds:**
1. Use Docker deployment for consistent environment (Linux containers on any OS)
2. Use WSL2 on Windows for better Linux compatibility
3. Cloud deployment for platforms with poor native support

---

### 2.3 Memory Requirements

**Minimum:** 8GB RAM
**Recommended:** 16GB RAM
**Optimal:** 32GB+ RAM (for batch processing)

**Why These Requirements:**
- **PE Analysis:** Full binary loading into memory
- **Image Processing:** High-resolution steganography analysis
- **ML Models:** OpenVINO models require GPU memory
- **Concurrent Processing:** Batch mode runs multiple workers

**Impact:**
- Systems with <8GB RAM may crash on large samples
- Batch processing limited to fewer concurrent workers on low-memory systems
- Steganography analysis may be skipped to preserve memory

**Workarounds:**
1. Reduce recursion depth to limit memory usage:
   ```ini
   [pipeline]
   max_recursion_depth = 2
   ```
2. Disable memory-intensive modules:
   ```ini
   [steganography_analyzer]
   enabled = false
   ```
3. Process files sequentially instead of batch mode
4. Use swap space (slower but prevents crashes)

---

## 3. Feature Limitations

### 3.1 Supported File Formats

**Fully Supported:**
- PE/PE32+ executables (.exe, .dll, .sys)
- JPEG images (.jpg, .jpeg)
- PNG images (.png)
- BMP images (.bmp)
- ZIP archives (.zip)

**Partially Supported:**
- ELF binaries (basic analysis only, no specialized Linux malware detection)
- GIF images (polyglot detection only, no steganography analysis)
- PDF files (polyglot detection only, no content analysis)

**Not Supported:**
- Mach-O binaries (macOS executables)
- Android APK files (requires DEX analysis)
- Microsoft Office documents (docx, xlsx, pptx)
- Script-based malware (PowerShell, JavaScript, VBScript)
- Archive formats (RAR, 7z, tar)

**Why This Design:**
- **Focused Scope:** Deep analysis of PE files (primary APT41 target)
- **Complexity:** Each format requires specialized parsers and analyzers
- **Resource Constraints:** Cannot maintain expertise in all formats

**Workarounds:**
1. Extract PE payloads from unsupported containers before analysis
2. Use format-specific tools in combination:
   - APK: Jadx, Apktool
   - Office: OleVBA, oletools
   - Scripts: PowerShell AST analysis, JStillery
3. Convert/extract to supported formats where possible

**Extensibility:**
Adding new file format support requires implementing a custom analyzer module. See `docs/MODULE-DEVELOPMENT.md` for guidance.

---

### 3.2 Decryption Algorithms

**Supported:**
- XOR (single-byte, multi-byte, rolling)
- AES (128/192/256-bit, ECB/CBC/CTR/GCM modes)
- RC4 stream cipher
- ChaCha20 stream cipher
- APT41/KeyPlug custom algorithms

**Not Supported:**
- RSA asymmetric encryption (no private key brute-forcing)
- Blowfish, Twofish, Serpent
- Exotic or custom ciphers without known patterns
- Quantum-resistant algorithms (Kyber, Dilithium)

**Why This Design:**
- **Common Algorithms:** Focus on what APT41 actually uses
- **Computational Feasibility:** Some algorithms infeasible to brute-force
- **Key Management:** Asymmetric crypto requires private keys

**Impact:**
- Cannot decrypt payloads using unsupported algorithms
- May incorrectly identify encrypted data as random noise
- Limited utility for analyzing non-APT41 malware with exotic crypto

**Workarounds:**
1. Use external crypto analysis tools (CyberChef, cryptool)
2. Analyze encryption routines statically to infer algorithm
3. Extract keys from memory dumps (requires dynamic analysis)
4. Contribute algorithm implementations via pull request

---

### 3.3 Steganography Detection

**Supported:**
- Least Significant Bit (LSB) embedding in PNG/BMP
- Appended data beyond EOF markers
- JPEG DCT coefficient analysis (partial)
- Palette manipulation detection

**Limited Support:**
- Advanced JPEG steganography (F5, OutGuess - detection only, no extraction)
- Frequency domain analysis (present but not comprehensive)

**Not Supported:**
- Audio steganography (WAV, MP3, FLAC)
- Video steganography (MP4, AVI)
- Network steganography (covert channels)
- Text steganography (whitespace, Unicode)

**Why This Design:**
- **APT41 Tactics:** Focus on image-based steganography used by KeyPlug
- **Complexity:** Audio/video analysis requires different skillsets
- **Performance:** Frequency domain analysis is computationally expensive

**Impact:**
- May miss payloads hidden in unsupported media types
- Limited efficacy against cutting-edge steganography techniques
- No detection of covert channels in network protocols

**Workarounds:**
1. Use specialized steganography tools:
   - Audio: DeepSound, OpenStego
   - Video: OpenPuff, StegoVideo
2. Manual frequency domain analysis with MATLAB/Octave
3. Combine with network forensics tools (Wireshark, Zeek)

---

### 3.4 Code Analysis Capabilities

**Supported:**
- x86/x64 disassembly (Capstone)
- Control flow graph construction
- API call enumeration
- String extraction
- Anti-debug/anti-VM detection

**Limited Support:**
- ARM/ARM64 disassembly (basic support, no specialized analysis)
- MIPS, PowerPC architectures (not supported)

**Not Supported:**
- Decompilation to high-level code (C/C++)
- Symbolic execution
- Emulation/dynamic execution
- Automatic unpacking of complex packers (Themida, VMProtect)

**Why This Design:**
- **Complexity:** Decompilation requires sophisticated type inference
- **Tool Ecosystem:** Excellent external tools exist (IDA Pro, Ghidra, Binary Ninja)
- **Performance:** Symbolic execution too slow for production use
- **Static Analysis:** KP14 focuses on static analysis, not emulation

**Impact:**
- Cannot automatically recover high-level source code
- Complex control flow obfuscation may confuse analyzer
- Heavily packed samples may require manual unpacking

**Workarounds:**
1. Use KP14 for initial triage, then export to IDA/Ghidra for deep analysis
2. Manually unpack samples with generic unpackers (UPX, ASPack)
3. Use Radare2 integration for enhanced disassembly
4. Leverage KP14's IDA script export feature for automated follow-up

**Integration:**
KP14 can export IDA Pro scripts for automatic navigation to suspicious code patterns. See `docs/IDA-INTEGRATION.md`.

---

### 3.5 Network Intelligence Extraction

**Supported:**
- IPv4/IPv6 address extraction from static strings
- Domain name identification
- URL parsing
- .onion address detection (Tor)
- Hardcoded proxy configurations

**Limited Support:**
- Obfuscated network indicators (Base64, XOR encoded)
- DGA (Domain Generation Algorithm) detection (heuristic-based)

**Not Supported:**
- Dynamic DNS resolution (requires runtime execution)
- C2 protocol analysis (HTTP/HTTPS/custom protocols)
- Network traffic generation or replay
- Active scanning of extracted C2 infrastructure

**Why This Design:**
- **Static Analysis:** Cannot observe actual network behavior
- **Safety:** Active scanning risks alerting adversaries
- **Legal:** Automated C2 probing raises legal/ethical concerns

**Impact:**
- May miss dynamically generated C2 endpoints
- Cannot verify if extracted addresses are actually active
- Limited understanding of C2 communication protocols

**Workarounds:**
1. Combine with PCAP analysis from dynamic sandbox
2. Use passive DNS databases (VirusTotal, PassiveTotal)
3. Integrate with OSINT tools for infrastructure correlation
4. Export indicators to threat intel platforms (MISP, OpenCTI)

**Safety Note:**
Never actively probe C2 infrastructure without proper authorization and legal guidance. Use extracted indicators for defensive purposes only.

---

## 4. Performance Limitations

### 4.1 Processing Speed

**Typical Performance (Intel Core Ultra 7, NPU enabled):**
- Small PE (<5MB): 1-3 seconds
- Medium PE (5-50MB): 3-15 seconds
- Large PE (50-100MB): 15-60 seconds
- JPEG steganography (10MB): 2-5 seconds
- Batch processing: ~100 samples/hour (mixed sizes)

**Bottlenecks:**
- Disassembly of large .text sections
- Steganography analysis of high-resolution images
- Cryptographic brute-forcing attempts
- Recursive analysis of deeply nested payloads

**Impact:**
- Not suitable for real-time malware triage (use hash lookups instead)
- Batch processing large sample collections may take hours
- Deep recursion can exponentially increase analysis time

**Workarounds:**
1. Enable NPU acceleration for 3-10× speedup
2. Use quick analysis profile for triage:
   ```bash
   python main.py --profile quick sample.exe
   ```
3. Disable slow modules for speed-critical workflows:
   ```ini
   [steganography_analyzer]
   enabled = false
   [crypto_analyzer]
   max_decryption_attempts = 10
   ```
4. Use parallel batch processing with multiple workers
5. Pre-filter samples by file type/size before deep analysis

---

### 4.2 Scalability Constraints

**Single System:**
- Max throughput: ~500-1000 samples/day (depending on hardware)
- Limited by memory, CPU cores, and storage I/O

**Not Supported:**
- Distributed processing across multiple nodes
- Cloud-native horizontal scaling (Kubernetes, AWS Batch)
- Message queue integration (RabbitMQ, Kafka)
- Load balancing across multiple instances

**Why This Design:**
- **Simplicity:** Single-system design reduces complexity
- **Target Use Case:** Security research labs with moderate sample volumes
- **Infrastructure:** Distributed systems require significant engineering

**Impact:**
- Cannot scale to handle millions of samples per day
- Not suitable for large-scale malware repositories (VirusTotal scale)
- Limited elasticity for traffic spikes

**Workarounds:**
1. Run multiple independent KP14 instances (manual distribution)
2. Use Docker Swarm or Kubernetes for basic orchestration
3. Implement custom queueing system (Redis + workers)
4. Partner with cloud-scale malware analysis platforms

**Enterprise Deployment:**
For >10,000 samples/day, consider custom enterprise deployment. Contact maintainers for consultation.

---

### 4.3 Real-time Analysis

**Limitation:**
KP14 is not designed for real-time, inline malware scanning.

**Why This Design:**
- **Analysis Depth:** Comprehensive analysis takes seconds/minutes, not milliseconds
- **Resource Intensive:** NPU/GPU resources needed for acceleration
- **Use Case:** Post-detection analysis, not prevention

**Impact:**
- Cannot be used as inline email attachment scanner
- Not suitable for real-time file system monitoring
- Incompatible with low-latency detection requirements

**Workarounds:**
1. Use lightweight scanners (YARA, ClamAV) for inline detection
2. Queue suspicious samples for KP14 deep analysis
3. Use KP14-generated YARA rules in real-time scanners
4. Implement two-stage detection: fast triage → deep analysis

**Recommended Architecture:**
```
Email Gateway → ClamAV (real-time) → Quarantine Queue → KP14 (batch) → Incident Response
```

---

## 5. Integration Limitations

### 5.1 SIEM and TIP Integration

**Supported:**
- JSON output for log ingestion (Splunk, Elastic, QRadar)
- STIX 2.1 bundles for threat intelligence platforms
- MISP event export
- CSV for spreadsheet analysis

**Limited Support:**
- OpenIOC format (basic implementation)
- Custom JSON schemas (requires manual mapping)

**Not Supported:**
- Direct API integration with SIEMs (no native connectors)
- Real-time streaming to log aggregators (Fluentd, Logstash)
- Bi-directional integration (cannot receive samples from SIEM)
- Automatic IOC enrichment from TIP platforms

**Why This Design:**
- **Universal Formats:** Focus on standard formats that work everywhere
- **Connector Complexity:** Each SIEM has unique API requirements
- **Maintenance Burden:** Keeping pace with platform API changes

**Impact:**
- Requires custom scripting to integrate with specific platforms
- No automated feedback loop from TIP to KP14
- Manual export/import workflows for most integrations

**Workarounds:**
1. Use JSON output with custom parsing scripts:
   ```bash
   python main.py --json sample.exe | parse_for_splunk.py
   ```
2. Leverage STIX/MISP for standardized threat intel sharing
3. Build custom connectors using KP14's Python API
4. Use middleware tools (MISP, OpenCTI) as integration hub

---

### 5.2 API Availability

**Current State:**
- CLI API with JSON output
- Python API via module imports
- No REST/HTTP API

**Planned (Q1 2026):**
- RESTful API with OpenAPI/Swagger documentation
- Webhook notifications for completed analyses
- Async job submission and status polling

**Impact:**
- Cannot integrate via HTTP requests (no web API)
- Language bindings limited to Python
- Requires shell execution for non-Python integrations

**Workarounds:**
1. Use subprocess calls from other languages:
   ```python
   import subprocess
   result = subprocess.run(['python', 'main.py', '--json', 'sample.exe'],
                          capture_output=True, text=True)
   ```
2. Import KP14 modules directly in Python applications
3. Build custom API wrapper using Flask/FastAPI
4. Wait for official REST API in v2.0 release

---

### 5.3 CI/CD Integration

**Supported:**
- GitHub Actions (workflow templates provided)
- Docker-based pipelines (GitLab CI, Jenkins)
- Exit code standardization (0=clean, 1=error, 2=malicious, 3=suspicious)

**Limited Support:**
- Quality gate integration (manual threshold configuration)
- Automated sample submission (requires custom scripting)

**Not Supported:**
- Native plugins for Jenkins, TeamCity, CircleCI
- Pre-commit hooks for malware scanning (too slow)
- Automated vulnerability remediation

**Why This Design:**
- **Generic Approach:** Docker containers work with all CI/CD systems
- **Speed:** Analysis too slow for real-time commit scanning
- **Use Case:** Post-build artifact scanning, not pre-commit

**Impact:**
- Requires custom pipeline configuration for each CI/CD system
- Cannot block commits based on analysis results
- Manual quality threshold enforcement

**Workarounds:**
1. Use provided GitHub Actions templates as reference
2. Create Docker-based pipeline stages
3. Implement custom quality gates based on threat score
4. Use KP14 in nightly/weekly scans, not per-commit

---

## 6. Accuracy and Detection Limitations

### 6.1 False Positives

**Expected Rate:**
- PE analysis: <1% false positives
- Behavioral analysis: 2-5% false positives (legitimate tools flagged)
- Steganography: 5-10% false positives (natural image patterns)
- Threat scoring: ±10 points variation

**Common False Positives:**
- Legitimate packers (UPX, NSPack) flagged as suspicious
- Security tools (debuggers, process monitors) detected as malware
- Steganography in artistic images (not actual hidden data)
- High entropy sections in compressed legitimate software

**Why This Occurs:**
- **Heuristic Analysis:** Pattern matching not perfect
- **Legitimate Dual-Use Tools:** Debuggers use same APIs as malware
- **Statistical Anomalies:** Natural high-entropy data mimics encryption

**Impact:**
- Requires manual review of flagged samples
- May overwhelm analysts with false alarms
- Reduced trust in automated classifications

**Workarounds:**
1. Whitelist known-good signatures (hashes, certificates)
2. Adjust detection thresholds in settings.ini:
   ```ini
   [obfuscation_analyzer]
   string_entropy_threshold = 5.5  # Increase to reduce FPs
   ```
3. Use threat score ranges instead of binary classification
4. Maintain organizational whitelist of legitimate tools
5. Combine KP14 with reputation databases (VirusTotal, NSRL)

**Best Practice:**
Treat threat scores >70 as "investigate further" not "definitely malicious". Always verify with additional sources.

---

### 6.2 False Negatives

**Known Gaps:**
- Novel packing/obfuscation techniques
- Zero-day encryption algorithms
- Sophisticated steganography (F5, J-STEG variants)
- Fileless malware (no file to analyze)
- Living-off-the-land (LOLBin) techniques

**Why This Occurs:**
- **Signature-Based Detection:** New techniques not in pattern database
- **Evasion Techniques:** Malware designed to bypass static analysis
- **Arms Race:** Malware evolves faster than detection rules

**Impact:**
- May miss cutting-edge APT malware
- Limited efficacy against targeted, custom malware
- Cannot detect attacks without file artifacts

**Workarounds:**
1. Keep pattern database updated (monthly releases)
2. Combine with dynamic analysis for comprehensive coverage
3. Use behavioral analysis to catch novel techniques
4. Implement defense-in-depth (multiple detection layers)
5. Contribute new signatures when discovering novel techniques

**Mitigation Strategy:**
- Monthly pattern database updates
- Community-driven signature sharing
- Machine learning models retrained quarterly
- Active threat intelligence integration

---

### 6.3 Adversarial Evasion

**Known Evasion Techniques:**
- Entropy manipulation to appear normal
- Code obfuscation to confuse disassemblers
- Format confusion to bypass file type detection
- Time bombs to avoid analysis (static analysis immune)

**Why This Is Possible:**
- **Static Analysis Limitation:** Cannot observe runtime behavior
- **Adversarial Knowledge:** Attackers study detection tools
- **Arms Race:** Constant evolution of evasion techniques

**Impact:**
- Sophisticated adversaries can evade KP14 detection
- Nation-state malware may be specifically designed to bypass
- Effectiveness decreases against highly targeted attacks

**Workarounds:**
1. Use KP14 as one layer in defense-in-depth strategy
2. Combine with dynamic analysis and EDR telemetry
3. Implement detonation chambers for suspicious samples
4. Use YARA rules generated by KP14 in runtime environments
5. Continuously update detection patterns based on new intelligence

**Security Note:**
No static analysis tool is perfect. KP14 significantly raises the bar for attackers but cannot guarantee 100% detection.

---

## 7. Deployment and Operational Limitations

### 7.1 Air-Gapped Environments

**Supported:**
- Offline Docker image deployment
- No internet connectivity required for core functionality

**Limited Support:**
- Manual pattern database updates (no automatic updates)
- No integration with cloud threat intelligence feeds

**Not Supported:**
- Automatic threat intelligence enrichment
- Online reputation lookups (VirusTotal, etc.)
- License verification (if applicable in future versions)

**Why This Design:**
- **Security Requirement:** Many security labs operate air-gapped
- **Self-Contained:** All dependencies bundled in Docker image

**Impact:**
- Pattern database becomes stale without manual updates
- Cannot leverage real-time threat intelligence
- Limited context for newly discovered threats

**Workarounds:**
1. Implement manual update process (USB transfer of pattern database)
2. Maintain internal threat intelligence repository
3. Use one-way data diode for limited external intel integration
4. Export indicators for external enrichment, then import results

---

### 7.2 Multi-Tenancy and Isolation

**Current State:**
- Single-tenant design
- No built-in user authentication
- No sample/result isolation between users

**Not Supported:**
- Multi-user environments with access control
- Role-based permissions (analyst, admin, read-only)
- Sample confidentiality enforcement
- Audit logging of user actions

**Why This Design:**
- **Target Use Case:** Single security team, trusted environment
- **Complexity:** Multi-tenancy requires significant access control infrastructure

**Impact:**
- All users have full access to all samples and results
- Cannot enforce data segregation (e.g., per-customer samples in MSSP)
- Limited auditability for compliance requirements

**Workarounds:**
1. Deploy separate KP14 instances per team/customer
2. Use filesystem permissions for access control
3. Implement external authentication wrapper (Apache, nginx)
4. Build custom multi-tenant frontend using KP14's Python API

**Enterprise Consideration:**
Multi-tenancy is a common request. Vote for issue #TBD if your organization needs this feature.

---

### 7.3 High Availability

**Not Supported:**
- Active-active or active-passive clustering
- Automatic failover
- Shared storage across instances
- Load balancer integration

**Why This Design:**
- **Complexity:** HA infrastructure requires distributed systems expertise
- **Use Case:** Analysis tool, not critical infrastructure
- **Stateless:** Individual analyses are independent (natural eventual consistency)

**Impact:**
- Downtime during system maintenance or failures
- No automatic recovery from hardware failures
- Manual intervention required for disaster recovery

**Workarounds:**
1. Use infrastructure-level HA (VM live migration, Kubernetes)
2. Deploy multiple independent instances with external load balancing
3. Implement retry logic in client applications
4. Maintain cold standby for disaster recovery

---

## 8. Documentation and Support Limitations

### 8.1 Documentation Coverage

**Well Documented:**
- Installation and setup
- Basic usage and CLI reference
- Configuration options
- Docker deployment

**Partially Documented:**
- Advanced configuration tuning
- Custom module development
- Performance optimization
- Enterprise deployment patterns

**Not Documented:**
- Source code (minimal inline comments)
- Algorithm implementation details
- Internal APIs (subject to change)

**Why This Gap:**
- **Resource Constraints:** Documentation is time-intensive
- **Rapid Development:** Internal APIs change frequently
- **Community Contribution:** Expecting community-driven documentation

**Impact:**
- Steep learning curve for advanced features
- Difficulty extending or modifying KP14
- Limited understanding of detection logic

**Workarounds:**
1. Review example configurations in `examples/` directory
2. Read source code for advanced understanding
3. Ask questions in GitHub Discussions
4. Contribute documentation improvements via pull requests

**Contribution Opportunity:**
Documentation contributions are highly valued. See `CONTRIBUTING.md` for guidelines.

---

### 8.2 Community Support

**Available Support:**
- GitHub Issues for bug reports
- GitHub Discussions for questions
- README and documentation
- Example configurations

**Not Available:**
- 24/7 support hotline
- SLA commitments
- Dedicated support engineer
- Custom feature development on demand

**Why This Model:**
- **Open Source:** Community-driven support model
- **Resource Constraints:** Limited maintainer availability
- **Best Effort:** No commercial support contracts

**Impact:**
- Response times vary (hours to days)
- No guaranteed resolution timelines
- Limited support for custom deployments

**Workarounds:**
1. Search GitHub Issues for similar problems
2. Provide detailed bug reports with reproduction steps
3. Engage with community for peer support
4. Consider commercial support offerings (if/when available)

---

### 8.3 Training and Onboarding

**Available Resources:**
- Quick start guide
- Video tutorials (planned)
- Example workflows

**Not Available:**
- Formal training courses
- Certification programs
- Instructor-led workshops
- Custom onboarding for enterprises

**Impact:**
- Self-service learning required
- Longer time to proficiency
- Potential misuse or misunderstanding of features

**Workarounds:**
1. Allocate time for team members to experiment
2. Create internal knowledge base based on experience
3. Attend security conferences where KP14 is discussed
4. Request training resources via GitHub Discussions

---

## 9. Legal and Compliance Limitations

### 9.1 Malware Handling

**User Responsibility:**
- Proper malware handling and storage
- Compliance with local laws regarding malware possession
- Ensuring samples are obtained legally (not from piracy/theft)

**KP14 Does NOT:**
- Validate legality of analyzed samples
- Enforce malware handling best practices
- Implement mandatory access controls for malware storage

**Impact:**
- Users must ensure legal compliance independently
- Inappropriate use may violate laws or regulations
- KP14 maintainers not responsible for illegal usage

**Best Practices:**
1. Store malware in encrypted, access-controlled repositories
2. Follow industry standards (FIRST, MISP TLP markings)
3. Obtain legal counsel for malware research programs
4. Implement strict need-to-know access policies

---

### 9.2 Export Controls

**Cryptographic Software:**
- KP14 contains cryptographic libraries (PyCryptodome)
- May be subject to export control regulations (EAR, ITAR)
- Users responsible for compliance with export laws

**Impact:**
- Distribution to certain countries may be restricted
- Enterprise deployments may require export licenses
- International collaboration may face legal hurdles

**Guidance:**
1. Consult legal counsel before international distribution
2. Review applicable export regulations (US EAR, EU regulations)
3. Consider jurisdiction-specific versions if needed

---

### 9.3 Liability and Warranty

**MIT License:**
- Software provided "as is" without warranty
- No liability for damages or losses
- No guarantee of detection accuracy

**User Responsibility:**
- Independent validation of results
- Not relying solely on KP14 for critical security decisions
- Implementing defense-in-depth strategies

**Impact:**
- Users bear all risks of using KP14
- No recourse for false negatives leading to breaches
- Critical environments require additional validation

---

## 10. Roadmap and Future Limitations

### 10.1 Features Not Planned

The following features are NOT on the roadmap and unlikely to be implemented:

1. **Dynamic Analysis / Sandboxing**
   - Too complex, excellent external tools exist

2. **Full Decompilation to C/C++**
   - IDA Pro, Ghidra already solve this problem

3. **Mobile Malware Analysis (APK, IPA)**
   - Different expertise domain, requires separate tool

4. **Network Traffic Analysis**
   - Use Wireshark, Zeek, or Snort instead

5. **Automated Malware Removal**
   - Too risky, use EDR/antivirus solutions

---

### 10.2 Planned Improvements

See `ROADMAP.md` for detailed timeline. Key improvements:

- **Q1 2026:** REST API, Apple Silicon support
- **Q2 2026:** Enhanced behavioral analysis, DGA detection
- **Q3 2026:** Multi-malware family support, improved ML models
- **Q4 2026:** Distributed processing, enterprise features

---

## 11. Recommendations

### When to Use KP14

- Initial malware triage and classification
- Steganography detection in suspect images
- C2 infrastructure extraction from binaries
- Batch analysis of malware sample collections
- APT41/KeyPlug campaign analysis
- Generating YARA rules for detection

### When NOT to Use KP14

- Real-time malware detection (too slow)
- Comprehensive dynamic behavior analysis (static analysis only)
- Non-PE file formats (limited support)
- Production endpoint protection (use EPP/EDR instead)
- Analyzing non-APT41 malware exclusively (use general-purpose tools)

### Complementary Tools

Recommended tools to use alongside KP14:

1. **Dynamic Analysis:** Cuckoo Sandbox, ANY.RUN, Joe Sandbox
2. **Decompilation:** IDA Pro, Ghidra, Binary Ninja
3. **Memory Forensics:** Volatility, Rekall
4. **Network Analysis:** Wireshark, Zeek, Suricata
5. **Threat Intelligence:** MISP, OpenCTI, ThreatConnect
6. **General Malware Analysis:** YARA, Capa, PEStudio

---

## 12. Feedback and Contributions

### Reporting Limitations

If you encounter a limitation not documented here:

1. Check GitHub Issues to see if it's already reported
2. Open a new issue with tag `limitation` or `feature-request`
3. Describe the use case and impact
4. Propose workarounds if known

### Contributing Improvements

To address limitations:

1. Fork the repository
2. Implement enhancements following `CONTRIBUTING.md` guidelines
3. Submit pull request with tests and documentation
4. Engage with maintainers during review process

### Feature Requests

For new features addressing limitations:

1. Open GitHub Discussion in "Ideas" category
2. Describe use case and benefits
3. Gauge community interest
4. Volunteer to implement if possible

---

## Version History

- **v1.0** (2025-10-02): Initial limitations documentation
- **v1.1** (TBD): Updates based on v2.0 release

---

## Conclusion

KP14 is a powerful, specialized tool for static malware analysis with a focus on APT41's KeyPlug malware family. Understanding its limitations allows you to use it effectively as part of a comprehensive security strategy.

Key takeaways:

1. **Static analysis only** - use dynamic tools for runtime behavior
2. **Hardware acceleration** - Intel-specific, but optional
3. **Focused scope** - excellent for KeyPlug, adequate for other malware
4. **Complementary tool** - use alongside other analysis platforms
5. **Active development** - many limitations will be addressed in future releases

For questions or clarifications, please open a GitHub Discussion.

**Document maintained by:** KP14 Core Team
**Last reviewed:** 2025-10-02
**Next review:** 2025-11-02
