"""Rule Export Module - Generate detection rules from analysis results"""

import hashlib
from typing import Dict, Any, List
from pathlib import Path
from datetime import datetime


class YARAExporter:
    """Export YARA rules from analysis results"""

    def __init__(self):
        """Initialize YARA exporter"""
        pass

    def export(self, result: Dict[str, Any], output_path: str = None) -> str:
        """
        Generate YARA rule from analysis result

        Args:
            result: Analysis result dictionary
            output_path: Optional file path to write rule

        Returns:
            YARA rule string
        """
        rule = self._create_yara_rule(result)

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w') as f:
                f.write(rule)

        return rule

    def _create_yara_rule(self, result: Dict[str, Any]) -> str:
        """Create YARA rule from analysis result"""
        pe_info = result.get('static_pe_analysis', {}).get('pe_info', {})
        intelligence = result.get('intelligence', {})
        threat = result.get('threat_assessment', {})

        # Generate rule name
        filename = Path(result.get('file_path', 'unknown')).stem
        safe_name = ''.join(c if c.isalnum() else '_' for c in filename)
        rule_name = f"KP14_{safe_name}_{datetime.utcnow().strftime('%Y%m%d')}"

        # Start rule
        lines = [
            f"rule {rule_name}",
            "{",
            "    meta:",
            f"        description = \"Auto-generated by KP14 for {filename}\"",
            f"        author = \"KP14 Automated Analysis\"",
            f"        date = \"{datetime.utcnow().strftime('%Y-%m-%d')}\"",
            f"        threat_level = \"{threat.get('level', 'unknown')}\"",
        ]

        # Add malware family if detected
        if intelligence.get('malware_family'):
            lines.append(f"        malware_family = \"{intelligence['malware_family']}\"")

        # Add hashes
        hashes = pe_info.get('hashes', {})
        if isinstance(hashes, dict):
            if hashes.get('md5'):
                lines.append(f"        md5 = \"{hashes['md5']}\"")
            if hashes.get('sha256'):
                lines.append(f"        sha256 = \"{hashes['sha256']}\"")

        lines.append("")
        lines.append("    strings:")

        # Add string indicators
        string_count = 0

        # Add C2 endpoints as strings
        for c2 in intelligence.get('c2_endpoints', [])[:5]:
            string_count += 1
            lines.append(f"        $c2_{string_count} = \"{c2}\" ascii wide")

        # Add suspicious imports
        if pe_info.get('imports'):
            suspicious_imports = ['CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory']
            for dll, funcs in list(pe_info['imports'].items())[:3]:
                for func in funcs:
                    if any(susp in func for susp in suspicious_imports):
                        string_count += 1
                        lines.append(f"        $import_{string_count} = \"{func}\" ascii")

        # Add hex patterns if available
        if pe_info.get('sections'):
            for section in pe_info['sections'][:2]:
                if section.get('name') == '.text':
                    # Add a simple hex pattern (placeholder - would need actual bytes)
                    string_count += 1
                    lines.append(f"        $code_{string_count} = {{ 55 8B EC }}  // push ebp; mov ebp, esp")

        lines.append("")
        lines.append("    condition:")

        # Build condition
        if string_count > 0:
            if intelligence.get('malware_family'):
                lines.append(f"        (uint16(0) == 0x5A4D) and  // PE header")
                lines.append(f"        (filesize < 10MB) and")
                lines.append(f"        (2 of ($c2_*) or 2 of ($import_*))")
            else:
                lines.append(f"        (uint16(0) == 0x5A4D) and  // PE header")
                lines.append(f"        (any of them)")
        else:
            lines.append(f"        uint16(0) == 0x5A4D  // PE header")

        lines.append("}")
        lines.append("")

        return '\n'.join(lines)


class SuricataExporter:
    """Export Suricata rules from analysis results"""

    def __init__(self):
        """Initialize Suricata exporter"""
        self.sid_base = 9000000  # Custom SID range

    def export(self, result: Dict[str, Any], output_path: str = None) -> List[str]:
        """
        Generate Suricata rules from analysis result

        Args:
            result: Analysis result dictionary
            output_path: Optional file path to write rules

        Returns:
            List of Suricata rule strings
        """
        rules = self._create_suricata_rules(result)

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w') as f:
                for rule in rules:
                    f.write(rule + '\n')

        return rules

    def _create_suricata_rules(self, result: Dict[str, Any]) -> List[str]:
        """Create Suricata rules from analysis result"""
        intelligence = result.get('intelligence', {})
        rules = []

        # Generate rules for C2 endpoints
        for idx, c2 in enumerate(intelligence.get('c2_endpoints', [])[:10]):
            sid = self.sid_base + idx

            if c2.startswith('http'):
                # HTTP C2 rule
                domain = c2.split('/')[2]
                rule = (
                    f"alert http any any -> any any "
                    f"(msg:\"KP14 - Potential C2 Communication to {domain}\"; "
                    f"flow:established,to_server; "
                    f"content:\"{domain}\"; http_host; "
                    f"classtype:trojan-activity; "
                    f"sid:{sid}; rev:1;)"
                )
                rules.append(rule)

            elif ':' in c2:
                # IP:Port C2 rule
                ip, port = c2.split(':')
                rule = (
                    f"alert tcp any any -> {ip} {port} "
                    f"(msg:\"KP14 - Potential C2 Communication to {ip}:{port}\"; "
                    f"flow:established,to_server; "
                    f"classtype:trojan-activity; "
                    f"sid:{sid}; rev:1;)"
                )
                rules.append(rule)

        # Add DNS rule for domains
        for idx, c2 in enumerate(intelligence.get('c2_endpoints', [])):
            if not c2.startswith('http') and '.' in c2 and not any(c.isdigit() for c in c2.split('.')[0]):
                sid = self.sid_base + 100 + idx
                domain = c2.split(':')[0]
                rule = (
                    f"alert dns any any -> any any "
                    f"(msg:\"KP14 - DNS Query for Potential C2 Domain {domain}\"; "
                    f"dns_query; content:\"{domain}\"; nocase; "
                    f"classtype:trojan-activity; "
                    f"sid:{sid}; rev:1;)"
                )
                rules.append(rule)

        return rules


class SnortExporter:
    """Export Snort rules from analysis results"""

    def __init__(self):
        """Initialize Snort exporter"""
        self.sid_base = 9000000  # Custom SID range

    def export(self, result: Dict[str, Any], output_path: str = None) -> List[str]:
        """
        Generate Snort rules from analysis result

        Args:
            result: Analysis result dictionary
            output_path: Optional file path to write rules

        Returns:
            List of Snort rule strings
        """
        rules = self._create_snort_rules(result)

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w') as f:
                for rule in rules:
                    f.write(rule + '\n')

        return rules

    def _create_snort_rules(self, result: Dict[str, Any]) -> List[str]:
        """Create Snort rules from analysis result"""
        intelligence = result.get('intelligence', {})
        rules = []

        # Generate rules for C2 endpoints
        for idx, c2 in enumerate(intelligence.get('c2_endpoints', [])[:10]):
            sid = self.sid_base + idx

            if c2.startswith('http'):
                # HTTP C2 rule
                domain = c2.split('/')[2]
                rule = (
                    f"alert tcp any any -> any $HTTP_PORTS "
                    f"(msg:\"KP14 - Potential C2 Communication to {domain}\"; "
                    f"flow:to_server,established; "
                    f"content:\"Host: {domain}\"; http_header; nocase; "
                    f"classtype:trojan-activity; "
                    f"sid:{sid}; rev:1;)"
                )
                rules.append(rule)

            elif ':' in c2:
                # IP:Port C2 rule
                ip, port = c2.split(':')
                rule = (
                    f"alert tcp any any -> {ip} {port} "
                    f"(msg:\"KP14 - Potential C2 Communication to {ip}:{port}\"; "
                    f"flow:to_server,established; "
                    f"classtype:trojan-activity; "
                    f"sid:{sid}; rev:1;)"
                )
                rules.append(rule)

        return rules
