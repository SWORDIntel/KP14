import unittest
from unittest import mock
import logging
import os
# import json # F401 unused
import tempfile
from pathlib import Path
import uuid
import sys
# import shutil # For cleanup if needed, though tempfile usually handles it. # F401 unused

# Add project root to sys.path
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, PROJECT_ROOT)

try:
    from utils.malware_pattern_learner import MalwarePatternLearner
    LEARNER_AVAILABLE = True
except ImportError:
    print("Failed to import MalwarePatternLearner. Ensure malware_pattern_learner.py is in the Python path.")
    LEARNER_AVAILABLE = False

@unittest.skipIf(not LEARNER_AVAILABLE, "MalwarePatternLearner class not found, skipping tests.")
class TestMalwarePatternLearner(unittest.TestCase):

    def setUp(self):
        self.test_logger = logging.getLogger("TestMalwarePatternLearner")
        self.test_logger.setLevel(logging.DEBUG)
        if not self.test_logger.hasHandlers():
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.test_logger.addHandler(handler)

        self.temp_dir_obj = tempfile.TemporaryDirectory()
        self.temp_dir_path = Path(self.temp_dir_obj.name)
        self.temp_db_path = str(self.temp_dir_path / "test_malware_patterns.json")
        
        self.learner = MalwarePatternLearner(database_path=self.temp_db_path, logger=self.test_logger)
        # Ensure a clean, default DB for each test by calling initialize_idiom_database
        self.learner.initialize_pattern_database(force_recreate=True)
        self.test_logger.info(f"Setup complete. Test DB at: {self.temp_db_path}")

    def tearDown(self):
        self.temp_dir_obj.cleanup()
        self.test_logger.info(f"TearDown complete. Cleaned up temp directory: {self.temp_dir_path}")

    def test_initialization_and_default_db(self):
        self.test_logger.info("--- Test: Initialization and Default DB ---")
        self.assertIsNotNone(self.learner.patterns_db)
        self.assertIn("metadata", self.learner.patterns_db)
        self.assertIn("patterns", self.learner.patterns_db)
        self.assertEqual(len(self.learner.patterns_db["patterns"]), 0, "Default DB should have no patterns initially.")
        self.assertEqual(self.learner.patterns_db["metadata"]["version"], "0.2.0") # As per current learner

    def test_add_pattern_basic(self):
        self.test_logger.info("--- Test: Add Pattern Basic ---")
        pattern_details = {
            "type": "test_type",
            "description": "A test pattern.",
            "indicators": [{"type": "string_match", "value": "evil_string"}],
            "confidence": 0.75,
            "source_artifact": "test_sample.exe",
            "derived_from_module": "TestModule"
        }
        pattern_id = self.learner.add_pattern(pattern_details)
        
        self.assertIsNotNone(pattern_id)
        self.assertIsInstance(pattern_id, str)
        try:
            uuid.UUID(pattern_id, version=4) # Check if it's a valid UUID4
        except ValueError:
            self.fail("Pattern ID is not a valid UUID4 string.")

        self.assertEqual(len(self.learner.patterns_db["patterns"]), 1)
        added_pattern = self.learner.patterns_db["patterns"][0]
        
        self.assertEqual(added_pattern["pattern_id"], pattern_id)
        self.assertEqual(added_pattern["type"], pattern_details["type"])
        self.assertEqual(added_pattern["description"], pattern_details["description"])
        self.assertEqual(added_pattern["indicators"], pattern_details["indicators"])
        self.assertEqual(added_pattern["confidence"], pattern_details["confidence"])
        self.assertEqual(added_pattern["source_artifact"], pattern_details["source_artifact"])
        self.assertEqual(added_pattern["derived_from_module"], pattern_details["derived_from_module"])
        self.assertIn("created_at", added_pattern)
        self.assertIn("last_updated_at", added_pattern)

    @mock.patch.object(MalwarePatternLearner, '_save_database')
    def test_add_pattern_failure_to_save(self, mock_save_database):
        self.test_logger.info("--- Test: Add Pattern Failure to Save ---")
        mock_save_database.return_value = False # Simulate save failure

        pattern_details = {"type": "fail_save_type", "description": "This save should fail."}
        pattern_id = self.learner.add_pattern(pattern_details)
        
        self.assertIsNone(pattern_id, "Pattern ID should be None if save fails.")
        self.assertEqual(len(self.learner.patterns_db["patterns"]), 0, "Pattern should be rolled back if save fails.")
        mock_save_database.assert_called_once()

    def test_learn_from_analysis_generic_fallback(self):
        self.test_logger.info("--- Test: Learn from Analysis - Generic Fallback ---")
        analysis_results = {"file_name": "generic_sample.exe", "components": {}}
        learned_ids = self.learner.learn_from_analysis(analysis_results)
        
        self.assertEqual(len(learned_ids), 1, "Expected one generic pattern to be learned.")
        self.assertEqual(len(self.learner.patterns_db["patterns"]), 1)
        learned_pattern = self.learner.patterns_db["patterns"][0]
        self.assertEqual(learned_pattern["type"], "generic_analysis_observation")
        self.assertEqual(learned_pattern["source_artifact"], "generic_sample.exe")

    def test_learn_from_analysis_intent_based(self):
        self.test_logger.info("--- Test: Learn from Analysis - Intent Based ---")
        analysis_results = {
            "file_name": "intent_sample.exe",
            "components": {
                "CodeIntentClassifier": {
                    "intent": "networking_communication", "confidence": 0.9, "engine_type": "sklearn"
                }
            }
        }
        learned_ids = self.learner.learn_from_analysis(analysis_results)
        self.assertEqual(len(learned_ids), 1)
        learned_pattern = self.learner.patterns_db["patterns"][0]
        
        self.assertEqual(learned_pattern["type"], "code_intent_networking_communication")
        self.assertIn({"type": "intent", "value": "networking_communication"}, learned_pattern["indicators"])
        self.assertAlmostEqual(learned_pattern["confidence"], 0.9 * 0.6, places=2)
        self.assertEqual(learned_pattern["derived_from_module"], "CodeIntentClassifier")

    def test_learn_from_analysis_vulnerability_based_critical(self):
        self.test_logger.info("--- Test: Learn from Analysis - Vulnerability Based (Critical) ---")
        analysis_results = {
            "file_name": "vuln_gets_sample.exe",
            "components": {
                "VulnerabilityDetector": {
                    "pattern_scan": {
                        "vulnerabilities_found": [
                            {"pattern_name": "gets", "line_number": 10, "line_content": "gets(buf);", "description": "Use of gets..."}
                        ]
                    }
                }
            }
        }
        learned_ids = self.learner.learn_from_analysis(analysis_results)
        self.assertEqual(len(learned_ids), 1)
        learned_pattern = self.learner.patterns_db["patterns"][0]

        self.assertEqual(learned_pattern["type"], "vuln_gets")
        self.assertIn({"type": "vuln_signature", "value": "gets"}, learned_pattern["indicators"])
        self.assertIn({"type": "line_content_sample", "value": "gets(buf);"}, learned_pattern["indicators"])
        self.assertEqual(learned_pattern["confidence"], 0.85)
        self.assertEqual(learned_pattern["derived_from_module"], "VulnerabilityDetector_PatternScan")

    def test_learn_from_analysis_api_sequence_based(self):
        self.test_logger.info("--- Test: Learn from Analysis - API Sequence Based ---")
        analysis_results = {
            "file_name": "api_seq_sample.exe",
            "components": {
                "KeyplugApiSequenceDetector": { # Conceptual module name
                    "suspicious_api_sequences": [
                        ["CreateFileA", "WriteFile", "CloseHandle"],
                        ["RegOpenKeyExA", "RegQueryValueExA", "RegCloseKey"]
                    ]
                }
            }
        }
        learned_ids = self.learner.learn_from_analysis(analysis_results)
        # Expects 2 patterns from sequences + 1 generic fallback if no other heuristic hits
        # If other heuristics are added and hit, this count might need adjustment or
        # the generic fallback check should be more specific.
        # For now, assuming ONLY this heuristic hits for this test data.
        # Update: The current logic creates a generic pattern if no *other* specific pattern was found.
        # Since API sequence is specific, the generic one won't be created if this hits.
        self.assertEqual(len(learned_ids), 2, "Expected two API sequence patterns.")
        
        pattern_types = [p["type"] for p in self.learner.patterns_db["patterns"]]
        self.assertIn("suspicious_api_sequence", pattern_types)
        
        found_patterns = [p for p in self.learner.patterns_db["patterns"] if p["type"] == "suspicious_api_sequence"]
        self.assertEqual(len(found_patterns), 2)
        self.assertIn({"type": "api_sequence", "value": "CreateFileA_WriteFile_CloseHandle"}, found_patterns[0]["indicators"])
        self.assertIn({"type": "api_sequence", "value": "RegOpenKeyExA_RegQueryValueExA_RegCloseKey"}, found_patterns[1]["indicators"])

    def test_learn_from_analysis_code_keyword_based(self):
        self.test_logger.info("--- Test: Learn from Analysis - Code Keyword Based ---")
        dummy_c_content = """
        #include <windows.h>
        void do_process_stuff() {
            CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
            Process32First(0,0); // Simplified
        }
        void do_hooking() {
            SetWindowsHookExA(WH_KEYBOARD_LL, NULL, NULL, 0);
        }
        """
        dummy_c_file = self.temp_dir_path / "sample_code_for_keywords.c"
        with open(dummy_c_file, "w") as f:
            f.write(dummy_c_content)

        analysis_results = {
            "file_name": "keyword_sample.exe",
            "components": {
                "DecompilerIntegration": {
                    "consensus_c_code": str(dummy_c_file) # Path to the dummy C file
                }
            }
        }
        learned_ids = self.learner.learn_from_analysis(analysis_results)
        self.assertEqual(len(learned_ids), 2) # Expecting two keyword patterns

        pattern_types = [p["type"] for p in self.learner.patterns_db["patterns"]]
        self.assertIn("code_idiom_process_enumeration", pattern_types)
        self.assertIn("code_idiom_windows_hooking", pattern_types)

        proc_enum_pattern = next(p for p in self.learner.patterns_db["patterns"] if p["type"] == "code_idiom_process_enumeration")
        self.assertIn({"type": "code_keyword", "value": "CreateToolhelp32Snapshot"}, proc_enum_pattern["indicators"])

if __name__ == '__main__':
    if not LEARNER_AVAILABLE:
        print("WARNING: MalwarePatternLearner class not found. Skipping tests.")
        sys.exit(0)
        
    logging.basicConfig(stream=sys.stderr, level=logging.DEBUG, 
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    unittest.main()
