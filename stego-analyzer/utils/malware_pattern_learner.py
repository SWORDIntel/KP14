import logging
import json
import os
from datetime import datetime, timezone # For timezone-aware timestamps
import uuid
from typing import Dict, List, Optional, Any

class MalwarePatternLearner:
    def __init__(self, database_path: str = "malware_patterns.json", logger: Optional[logging.Logger] = None):
        self.database_path: str = database_path
        self.logger = logger if logger else logging.getLogger(self.__class__.__name__)
        if not logger and not logging.getLogger().hasHandlers():
            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        
        self.patterns_db: Dict[str, Any] = {}
        self.initialize_pattern_database()

    def _get_timestamp(self) -> str:
        """Returns a timezone-aware ISO formatted timestamp."""
        return datetime.now(timezone.utc).isoformat()

    def initialize_pattern_database(self, force_recreate: bool = False) -> None:
        """
        Initializes the pattern database. Loads from existing file or creates a new one.
        """
        if not force_recreate and os.path.exists(self.database_path):
            if self._load_database():
                self.logger.info(f"Successfully loaded existing pattern database from {self.database_path}")
                if "metadata" not in self.patterns_db: self.patterns_db["metadata"] = {}
                if "patterns" not in self.patterns_db: self.patterns_db["patterns"] = []
                self.patterns_db["metadata"]["last_loaded_at"] = self._get_timestamp()
                return 

            self.logger.warning(f"Failed to load database from {self.database_path}. Will create a new one.")
        
        self.logger.info(f"Initializing new pattern database at {self.database_path} (force_recreate={force_recreate})")
        self.patterns_db = {
            "metadata": {
                "created_at": self._get_timestamp(),
                "updated_at": self._get_timestamp(),
                "version": "0.2.0", # Updated version for new heuristics
                "description": "Database of learned malware patterns."
            },
            "patterns": [] 
        }
        if not self._save_database():
             self.logger.error(f"Failed to save newly created database to {self.database_path}. Operations may not persist.")

    def _load_database(self) -> bool:
        try:
            if not os.path.exists(self.database_path):
                self.logger.info(f"Database file {self.database_path} does not exist. Cannot load.")
                return False
            with open(self.database_path, 'r', encoding='utf-8') as f:
                self.patterns_db = json.load(f)
            self.logger.debug(f"Database loaded successfully from {self.database_path}.")
            return True
        except Exception as e: 
            self.logger.error(f"Unexpected error loading database {self.database_path}: {e}")
            self.patterns_db = {}
            return False

    def _save_database(self) -> bool:
        if not self.patterns_db: 
            self.logger.warning("Attempted to save an empty or uninitialized patterns_db. Save aborted.")
            return False
            
        try:
            if "metadata" not in self.patterns_db: self.patterns_db["metadata"] = {}
            self.patterns_db["metadata"]["updated_at"] = self._get_timestamp()
            
            db_dir = os.path.dirname(self.database_path)
            if db_dir and not os.path.exists(db_dir): 
                os.makedirs(db_dir, exist_ok=True)
                self.logger.info(f"Created directory for database: {db_dir}")

            with open(self.database_path, 'w', encoding='utf-8') as f:
                json.dump(self.patterns_db, f, indent=2, ensure_ascii=False)
            self.logger.debug(f"Database saved successfully to {self.database_path}.")
            return True
        except Exception as e: 
            self.logger.error(f"Unexpected error saving database {self.database_path}: {e}")
            return False

    def add_pattern(self, pattern_details: Dict[str, Any]) -> Optional[str]:
        if "patterns" not in self.patterns_db:
            self.logger.error("Pattern database not correctly initialized (missing 'patterns' list). Cannot add pattern.")
            self.patterns_db["patterns"] = [] 

        pattern_id = str(uuid.uuid4())
        new_pattern = {
            "pattern_id": pattern_id,
            "type": pattern_details.get("type", "unknown_pattern_type"),
            "description": pattern_details.get("description", "No description provided."),
            "indicators": pattern_details.get("indicators", []), # Changed from "signatures"
            "confidence": max(0.1, min(1.0, pattern_details.get("confidence", 0.1))), # Ensure confidence is 0.1-1.0
            "source_artifact": pattern_details.get("source_artifact", "unknown_artifact"),
            "derived_from_module": pattern_details.get("derived_from_module", "unknown_module"),
            "created_at": self._get_timestamp(),
            "last_updated_at": self._get_timestamp(),
        }
        self.patterns_db["patterns"].append(new_pattern)
        self.logger.info(f"Added new pattern '{pattern_id}' of type '{new_pattern['type']}'.")
        
        if self._save_database():
            return pattern_id
        else:
            self.patterns_db["patterns"] = [p for p in self.patterns_db["patterns"] if p.get("pattern_id") != pattern_id]
            self.logger.error(f"Failed to save database after attempting to add pattern {pattern_id}. Pattern not added.")
            return None

    def learn_from_analysis(self, analysis_results: Dict[str, Any]) -> List[str]:
        file_name = analysis_results.get("file_name", "unknown_file")
        self.logger.info(f"Learning from analysis results of '{file_name}'.")
        
        components_results = analysis_results.get("components", {})
        learned_pattern_ids = []

        # Heuristic 1: CodeIntentClassifier
        intent_results = components_results.get("CodeIntentClassifier", {})
        if intent_results and isinstance(intent_results, dict):
            intent = intent_results.get("intent")
            confidence = intent_results.get("confidence", 0.0)
            if intent and intent not in ["unknown", "unknown_no_model_or_vectorizer", "unknown_dummy_model", "unknown_preprocess_failed", "unknown_classification_error", "unknown_model_missing_classes_attr"]:
                pattern_details = {
                    "type": f"code_intent_{intent.lower().replace(' ', '_')}",
                    "description": f"Dominant code intent observed: {intent}",
                    "indicators": [{"type": "intent", "value": intent}],
                    "confidence": max(0.1, confidence * 0.6), # Scale down intent confidence
                    "source_artifact": file_name,
                    "derived_from_module": "CodeIntentClassifier"
                }
                pid = self.add_pattern(pattern_details)
                if pid: learned_pattern_ids.append(pid)

        # Heuristic 2: VulnerabilityDetector
        vuln_analysis = components_results.get("VulnerabilityDetector", {})
        # Check pattern_scan results first
        pattern_vulns = vuln_analysis.get("pattern_scan", {}).get("vulnerabilities_found", [])
        if not pattern_vulns and isinstance(vuln_analysis.get("vulnerabilities_found"), list): # older format fallback
             pattern_vulns = vuln_analysis.get("vulnerabilities_found")
        pattern_vulns = pattern_vulns or []  # Ensure pattern_vulns is a list even if fallback is None

        for vuln in pattern_vulns:
            vuln_name = vuln.get("pattern_name")
            if vuln_name:
                confidence = 0.6 # Base for pattern-detected vulns
                if vuln_name in ["gets", "sprintf_non_literal_format"]:
                    confidence = 0.85
                elif vuln_name in ["strcpy", "strcat", "sprintf", "vsprintf"]:
                    confidence = 0.7
                
                pattern_details = {
                    "type": f"vuln_{vuln_name}",
                    "description": f"Specific vulnerability pattern observed: {vuln.get('description', vuln_name)}",
                    "indicators": [
                        {"type": "vuln_signature", "value": vuln_name},
                        {"type": "line_content_sample", "value": vuln.get("line_content", "")[:100]}
                    ],
                    "confidence": confidence,
                    "source_artifact": file_name,
                    "derived_from_module": "VulnerabilityDetector_PatternScan"
                }
                pid = self.add_pattern(pattern_details)
                if pid: learned_pattern_ids.append(pid)
        
        # Heuristic 3: API Call Sequences (Conceptual - KeyplugApiSequenceDetector)
        api_seq_results = components_results.get("KeyplugApiSequenceDetector", {})
        if api_seq_results and isinstance(api_seq_results, dict):
            suspicious_sequences = api_seq_results.get("suspicious_api_sequences", [])
            for seq in suspicious_sequences:
                if isinstance(seq, list) and len(seq) > 1: # Only consider sequences of 2 or more
                    seq_str = "_".join(seq)
                    pattern_details = {
                        "type": "suspicious_api_sequence",
                        "description": f"Suspicious API call sequence: {seq_str.replace('_', ' -> ')}",
                        "indicators": [{"type": "api_sequence", "value": seq_str}],
                        "confidence": 0.7, # Moderate confidence for conceptual sequences
                        "source_artifact": file_name,
                        "derived_from_module": "KeyplugApiSequenceDetector"
                    }
                    pid = self.add_pattern(pattern_details)
                    if pid: learned_pattern_ids.append(pid)

        # Heuristic 4: Decompiled Code Keywords (Conceptual - DecompilerIntegration)
        # This assumes orchestrator might pass some keywords or learner reads the C file.
        # For this subtask, we'll check for a conceptual `decompiled_keywords` list in results.
        decompiler_data = components_results.get("DecompilerIntegration", {})
        # conceptual_keywords = decompiler_data.get("decompiled_keywords", []) # Future: passed by orchestrator
        
        # Simplified: If a C file path exists, check for a few keywords as a demo.
        # In a real scenario, this would be more sophisticated or keywords passed by orchestrator.
        c_file_path = decompiler_data.get("consensus_c_code") or decompiler_data.get("primary_c_file_path") 
        conceptual_keywords_found = []

        if c_file_path is not None and os.path.exists(c_file_path):
            try:
                with open(c_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read(2048) # Read first 2KB for performance
                if "CreateToolhelp32Snapshot" in content and ("Process32First" in content or "Process32Next" in content):
                    conceptual_keywords_found.append("CreateToolhelp32Snapshot")
                    conceptual_keywords_found.append("Process32First/Next")
                if "SetWindowsHookEx" in content:
                    conceptual_keywords_found.append("SetWindowsHookEx")
            except Exception as e:
                self.logger.debug(f"Could not read/process C file {c_file_path} for keyword heuristic: {e}")

        if "CreateToolhelp32Snapshot" in conceptual_keywords_found and "Process32First/Next" in conceptual_keywords_found:
            pattern_details = {
                "type": "code_idiom_process_enumeration",
                "description": "Code suggests process enumeration using CreateToolhelp32Snapshot and Process32First/Next.",
                "indicators": [
                    {"type": "code_keyword", "value": "CreateToolhelp32Snapshot"},
                    {"type": "code_keyword", "value": "Process32First_OR_Process32Next"}
                ],
                "confidence": 0.6,
                "source_artifact": file_name,
                "derived_from_module": "DecompilerIntegration_KeywordHeuristic"
            }
            pid = self.add_pattern(pattern_details)
            if pid: learned_pattern_ids.append(pid)
        
        if "SetWindowsHookEx" in conceptual_keywords_found:
            pattern_details = {
                "type": "code_idiom_windows_hooking",
                "description": "Code suggests use of Windows hooking via SetWindowsHookEx.",
                "indicators": [{"type": "code_keyword", "value": "SetWindowsHookEx"}],
                "confidence": 0.65,
                "source_artifact": file_name,
                "derived_from_module": "DecompilerIntegration_KeywordHeuristic"
            }
            pid = self.add_pattern(pattern_details)
            if pid: learned_pattern_ids.append(pid)


        if not learned_pattern_ids: # Fallback if no specific patterns learned
            self.logger.info(f"  No specific new patterns derived from '{file_name}' via heuristics. Adding generic placeholder.")
            pattern_details = {
                "type": "generic_analysis_observation",
                "description": f"Generic observation from analysis of {file_name}.",
                "indicators": [{"type": "file_analyzed", "value": file_name}],
                "confidence": 0.1,
                "source_artifact": file_name,
                "derived_from_module": "learn_from_analysis_fallback"
            }
            pid = self.add_pattern(pattern_details)
            if pid: learned_pattern_ids.append(pid)
            
        return learned_pattern_ids


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
    main_logger = logging.getLogger("MalwarePatternLearnerExample")

    main_logger.info("--- Test Case 1: Default database path and basic add_pattern ---")
    learner1 = MalwarePatternLearner(logger=main_logger)
    main_logger.info(f"Initial DB state (default path): {json.dumps(learner1.patterns_db, indent=2)}")
    
    pattern_id1 = learner1.add_pattern({
        "type": "encryption_key_load", 
        "description": "Loads a hardcoded key into memory.",
        "indicators": [{"type": "asm_instruction", "value": "mov eax, 0xDEADBEEF"}, {"type": "asm_instruction", "value": "push eax"}], 
        "confidence": 0.7,
        "source_artifact": "case_123.exe",
        "derived_from_module": "manual_analysis"
    })
    main_logger.info(f"Pattern ID 1 added: {pattern_id1}")
    assert learner1.patterns_db["patterns"][0]["indicators"][0]["value"] == "mov eax, 0xDEADBEEF"

    main_logger.info("\n--- Test Case 2: learn_from_analysis with multiple heuristics ---")
    test_db_multi = "test_patterns_multi_heuristic.json"
    if os.path.exists(test_db_multi): os.remove(test_db_multi)
        
    learner_multi = MalwarePatternLearner(database_path=test_db_multi, logger=main_logger)
    learner_multi.initialize_pattern_database(force_recreate=True) 
    
    # Create a dummy C file for keyword heuristic to read
    dummy_c_file_path = "dummy_for_keyword_test.c"
    with open(dummy_c_file_path, "w") as f:
        f.write("int main() { SetWindowsHookExA(WH_KEYBOARD_LL, LowLevelKeyboardProc, hinstance, 0); return 0; }")

    analysis_res_multi = {
        "file_name": "multi_feature_sample.exe",
        "components": {
            "CodeIntentClassifier": {
                "intent": "keylogging", # More specific intent
                "confidence": 0.9,
            },
            "VulnerabilityDetector": { # Simulate pattern_scan structure
                "pattern_scan": {
                     "vulnerabilities_found": [
                        {"pattern_name": "gets", "line_number": 10, "line_content": "gets(buf);", "match_start_column": 0, "description": "Use of gets..."}
                    ]
                }
            },
            "KeyplugApiSequenceDetector": { # Conceptual
                "suspicious_api_sequences": [
                    ["OpenMutexA", "CreateFileMappingA", "MapViewOfFile"]
                ]
            },
            "DecompilerIntegration": { # For keyword heuristic
                "consensus_c_code": dummy_c_file_path 
            }
        }
    }
    learned_ids = learner_multi.learn_from_analysis(analysis_res_multi)
    main_logger.info(f"DB state after multi-heuristic learning: {json.dumps(learner_multi.patterns_db, indent=2)}")
    assert len(learned_ids) == 4, f"Expected 4 patterns, got {len(learned_ids)}"
    
    types_learned = [p["type"] for p in learner_multi.patterns_db["patterns"]]
    assert "code_intent_keylogging" in types_learned
    assert "vuln_gets" in types_learned
    assert "suspicious_api_sequence" in types_learned
    assert "code_idiom_windows_hooking" in types_learned

    api_seq_pattern = next(p for p in learner_multi.patterns_db["patterns"] if p["type"] == "suspicious_api_sequence")
    assert api_seq_pattern["indicators"][0]["value"] == "OpenMutexA_CreateFileMappingA_MapViewOfFile"

    hook_pattern = next(p for p in learner_multi.patterns_db["patterns"] if p["type"] == "code_idiom_windows_hooking")
    assert {"type": "code_keyword", "value": "SetWindowsHookEx"} in hook_pattern["indicators"]


    main_logger.info("\n--- Cleaning up test files ---")
    paths_to_remove = [test_db_multi, "malware_patterns.json", dummy_c_file_path]
    
    for p in paths_to_remove:
        if os.path.exists(p):
            os.remove(p)
            main_logger.info(f"Removed {p}")
    
    main_logger.info("--- All tests completed ---")
